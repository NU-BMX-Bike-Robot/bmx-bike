%% plot_robot.m
%
% Description:
%   Plots the robot in its current configuration.
%   
% Inputs:
%   q: robot configuration, q = [x_cart; theta_pend];
%   params: a struct with many elements, generated by calling init_params.m
%   varargin: optional name-value pair arguments:
%       'new_fig': (default: false), if true, plot appears on new figure
%
% Outputs:
%   none
%
% Notes:
%   1) This code is written verbosely in the hope that it is clear how to
%   extend it to visualizing other more complex robots.

function plot_robot(q,params,varargin)
%% Parse input arguments
% Note: a simple robot plotting function doesn't need this, but I want to
% write extensible code, so I'm using "varargin" which requires input
% parsing. See the reference below:
%
% https://people.umass.edu/whopper/posts/better-matlab-functions-with-the-inputparser-class/

% Step 1: instantiate an inputParser:
p = inputParser;

% Step 2: create the parsing schema:
%      2a: required inputs:
addRequired(p,'mw_config', ...
    @(q) isnumeric(q) && size(q,1)==2 && size(q,2)==1);
addRequired(p,'mw_params', ...
    @(params) ~isempty(params));
%      2b: optional inputs:
addParameter(p, 'new_fig', false); % if true, plot will be on a new figure

% Step 3: parse the inputs:
parse(p, q, params, varargin{:});

% Verification: display the results of parsing:
% disp(p.Results)


%% Compute the angle of the bike in roll-direction, clockwise from center-line
% extract the state-variables and parameters related to the momentum wheel
theta_bike = q(1);
theta_mw = q(2);

l_com = params.model.dyn.com.l;
offset = params.model.dyn.mw.offset;
mw_r = params.model.geom.mw.r;

% x_bike_mw = l_com*(sin(pi/2-theta_bike));
% y_bike_mw = l_com*(cos(pi/2-theta_bike));

x_bike_mw = (l_com+offset)*(cos(theta_bike));
y_bike_mw = (l_com+offset)*(sin(theta_bike));

g_wbike = [[cos(theta_bike),-sin(theta_bike), 0];
          [sin(theta_bike),cos(theta_bike), 0];
          [0, 0, 1]]

g_bike_mw = [[cos(theta_mw),-sin(theta_mw),x_mw];
             [sin(theta_mw),cos(theta_mw),y_mw];
             [0,0,1]];   
         
g_wmw = g_wbike*g_bike_mw;

g_bike_mw = [[1,0,x_bike_mw];
             [0,1,y_bike_mw];
             [0,0,1]];

body.home.mw.spook.x = mw_r*cos(theta_mw); %x origin of the spook in the MW frame
body.home.mw.spook.y = mw_r*sin(theta_mw); %y origin of the spook in the MW frame
spook = [body.home.mw.spook.x;body.home.mw.spook.y;1];
spook_tip = g_bike_mw*spook; %position of the spook in the bike's frame

%% Compute the roll-angle of the bike and location of the momentum wheels
body.home.com.x = l_com*cos(theta_bike); %x-center of the Bike
body.home.com.y = l_com*sin(theta_bike); %y-center of the Bike

body.home.mw.x = (l_com+offset)*cos(theta_bike); %x-center of the momentum wheel
body.home.mw.y = (l_com+offset)*sin(theta_bike); %y-center of the momentum wheel
                   
%% Display the Momentum Wheel
if p.Results.new_fig
    figure;
end

%
circle(body.home.mw.x,body.home.mw.y,mw_r,params.viz.colors.mw)
hold on;
%Create wheels
segment(body.home.mw.x, body.home.mw.y,spook_tip(1),spook_tip(2), 'red');
segment(0, 0, body.home.mw.x, body.home.mw.y, 'blue');


%Add Marker for CoM
%  plot(body.home.com.x, body.home.com.y,'o','MarkerSize',0.1,...
%      'MarkerFaceColor',params.viz.colors.wheels,...
%      'MarkerEdgeColor',params.viz.colors.wheels);
 
%Add ground line
yline(0);
xline(0); %add a center-line at x=0

hold off;

axis(params.viz.axis_lims);
daspect([1 1 1]) % no distortion

xlabel('$x$');
ylabel('$y$');

end


function circles = circle(x,y,r,c)
th = 0:pi/50:2*pi;
x_circle = r * cos(th) + x;
y_circle = r * sin(th) + y;
circles = plot(x_circle, y_circle);
fill(x_circle, y_circle, c)
end

function segments = segment(x1,y1,x2,y2,c)
x = [x1 x2];
y = [y1 y2];
segments = line(x,y,'Color',c);
end