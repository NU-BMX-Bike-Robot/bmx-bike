%% main.m
%
% Description:
%   Application entry point.
%
% Inputs: none
%
% Outputs: none
%
% Notes:

function main

%% Initialize environment
clear;
close all;
clc;

init_env();

%% Initialize parameters
params = init_params;

%% Visualize the robot in its initial state
x_IC = [params.sim.ICs.x_bf;
        params.sim.ICs.y_bf;
        params.sim.ICs.theta_com;
        params.sim.ICs.theta_bw;
        params.sim.ICs.theta_fw;
        params.sim.ICs.dx_com;
        params.sim.ICs.dy_com;
        params.sim.ICs.dtheta_com;
        params.sim.ICs.dtheta_bw;
        params.sim.ICs.dtheta_fw];

t_curr = 0;

% create a place for constraint forces populated in
% robot_dynamic_constraints function
F_calc = [];
tsim = [];
xsim = [];

% create a place for events
events = [];
i = 0;

% Set integration options - mainly events
options = odeset('Events',@robot_events,'RelTol',1e-3); %,'AbsTol',1e-3);

while params.sim.tfinal - t_curr > params.sim.dt
        
    tspan_passive = t_curr:params.sim.dt:params.sim.tfinal;
    
    [tseg, xseg, ~, ~, ie] = ode45(@robot_dynamics_constraints, tspan_passive, x_IC', options);
    
    % extract info from the integration
    tsim = [tsim;tseg]; % build up the time vector after each event
    xsim = [xsim;xseg]; % build up the calculated state after each event
    
    t_curr = tsim(end); % set the current time to where the integration stopped
    x_IC = xsim(end,:); % set the initial condition to where the integration stopped
    
    % if the simulation ended early, specify the new set of constraints
    % if simulation terminated before tfinal, update the constraints and, if necessary, the velocities
    if tseg(end) < params.sim.tfinal && ~isempty(ie)  % termination was triggered by an event
        if events(ie(1)) > 0
            disp('Check Constraint or collision')
            [x_IC] = change_constraints(x_IC,ie(1)); %ie is the index of the event triggered
        end
    end         
end

% transpose xsim_passive so that it is 5xN (N = number of timesteps):
 
 figure;
 
 xplot = xsim';
  
 % plot the x and y position of the back wheel
 subplot(2,1,1), plot(tsim,xplot(1,:),'b-',...
                      tsim,xplot(2,:),'r-','LineWidth',2);
                  
 % plot the angle of the COM and the back wheel
 subplot(2,1,2), plot(tsim,xplot(3,:),'b:',...
                      tsim,xplot(4,:),'r:','LineWidth',2);

 pause(1); % helps prevent animation from showing up on the wrong figure
 
% Let's resample the simulator output so we can animate with evenly-spaced
% points in (time,state).
% 1) deal with possible duplicate times in tsim:
% (https://www.mathworks.com/matlabcentral/answers/321603-how-do-i-interpolate-1d-data-if-i-do-not-have-unique-values
tsim = cumsum(ones(size(tsim)))*eps + tsim;

% 2) resample the duplicate-free time vector:
t_anim = 0:params.viz.dt:tsim(end);

% 3) resample the state-vs-time array:
% x_anim = interp1(tsim, xsim, t_anim); %x_anim doesn't run in airborne
x_anim = xsim'; % transpose so that xsim is 5xN (N = number of timesteps)
 
 animate_robot(x_anim(1:5,:),params,'trace_cart_com',false,...
     'trace_pend_com',false,'trace_pend_tip',false,'video',true);
 
 fprintf('Done passive simulation.\n');



function [dx] = robot_dynamics_constraints(t,x)
% Robot Dynamics
% Description:
%   Computes the constraint forces: 
%       Fnow = inv(A*Minv*A')*(A*Minv*(Q-H) + Adotqdot)
%
%   Also computes the derivative of the state:
%       x_dot(1:5) = (I - A'*inv(A*A')*A)*x(6:10)
%       x_dot(6:10) = inv(M)*(Q - H - A'F)
%
% Inputs:
%   t: time (scalar)
%   x: the 10x1 state vector
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   dx: derivative of state x with respect to time.
% for convenience, define q_dot
dx = zeros(numel(x),1);
nq = numel(x)/2;    % assume that x = [q;q_dot];
q_dot = x(nq+1:2*nq);

tau = params.model.dyn.tau_bw*0.05;


switch params.sim.trick
    
    case 'Wheelie'
        if t > 1 && t < 1.15
            tau = params.model.dyn.tau_bw;
        elseif t < 1.3 && t > 1.15
            tau = 0;
        elseif t > 2
            tau = params.model.dyn.tau_bw*0.1;
        end
    case 'Backflip' 
        
        if t > params.model.ramp_up_start && t < params.model.ramp_up_end
            tau = params.model.dyn.tau_bw;
        else
            tau = 0;
        end
end


Q = [0;0;0;tau;0];

% find the parts that don't depend on constraint forces
H = H_eom(x,params);
Minv = inv_mass_matrix(x,params);
[A_all,Hessian] = constraint_derivatives(x,params);

%% solve for constraint forces, if any; compute accelerations;  populate the events vector
n_active_constraints = sum(params.sim.constraints.active);  % number of active unilateral constraints

if n_active_constraints == 0  % if there are no constraints active, then there are no forces
    
    F_active = zeros(4,1);
    dx(1:nq) = q_dot;
    dx(nq+1:2*nq) = Minv*(Q - H);
    
else  % if there are constraints active, we must compute the constraint forces
    % initialize A and Adotqdot
    A = [];
    Adotqdot = [];
    
    % build A and Adotqdot, starting with unilateral constraints
    for ic=1:length(params.sim.constraints.active)    % cycle through all of the unilateral constraints
        if params.sim.constraints.active(ic) == 1    % if a constraint is active, add to A and Adotqdot
            A = [A;A_all(ic,:)];
            Adotqdot = [Adotqdot;q_dot'*Hessian(:,:,ic)*q_dot];
        end
    end
            
    % compute the constraint forces and accelerations
    F_active = (A*Minv*A')\(A*Minv*(Q - H) + Adotqdot);   % these are all the forces, unilateral and bilateral
    dx(1:nq) = (eye(nq) - A'*((A*A')\A))*x(6:10);
    dx(nq+1:2*nq) = Minv*(Q - H - A'*F_active);
        
end
% 6x1 vector of constraint forces
%F = zeros(6,1);
%F(params.sim.constraints.active) = F_active;

%Update events array to change constraints when required
events = update_events(x,F_active,params);

end

%% Event function for ODE45 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Description:
%   Event function that is called when a constraint becomes active or inactive
%
% Inputs:
%   t and x are required, but not used
%   events is shared with parent function
%
% Outputs:
%   value
%   isterminal
%   direction
function [value,isterminal,direction] = robot_events(~,~)

   value = events;
   isterminal = ones(length(events),1);
   direction = ones(length(events),1); %change to 1 or -1 

end


%% Function to handle changing constraints %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% change_constraints.m
%
% Description:
%   function to handle changes in constraints, depending on the current
%   status of params.sim.constraints as well as ie, the index of the last
%   event to occur
%
% Inputs:
%   x_IC: the current state of the robot, which will be the initial
%   conditions for the next segment of integration
%   ie: the index of events returned by robot_events.m
%
% Outputs:
%   x_IC: the current state of the robot, which might be updated if the
%   event that occurred was a collision

function [x_IC] = change_constraints(x_IC,ie)

A = [];
restitution = [];
collision = 0;
[C_all] = -constraints(x_IC,params);  
%for i1 = 1:length(ie) %checking the events triggered % I'm not sure if ie is ever a vector ... just being sure!
if params.sim.constraints.active(ie) == 1  % if the event came from an active constraint
    disp('Just change constraint')
    params.sim.constraints.active(ie) = 0; % then make the constraint inactive %already doing this
else    % the event came from an inactive constraint --> collision
    %if(C_all(ie) > 0)
    disp('Collision!')
    collision = 1;
    if(C_all(ie) > 0)
        params.sim.constraints.active(ie) = 1; % make the constraint active
    end
    % find the constraint jacobian                          
    [A_unilateral,~] = constraint_derivatives(x_IC,params); 
    A = A_unilateral(ie,:); %add new constraint row to A matrix
    restitution = 1 + params.model.dyn.wheel_res; %restitiution being zero
    %end
end
%end

if collision == 1
    
    Minv = inv_mass_matrix(x_IC,params);
    % compute the change in velocity due to collision impulses
    x_IC(6:10) = x_IC(6:10) - (Minv*A'*inv(A*Minv*A')*diag(restitution)*A*x_IC(6:10)')';
    % Often in a collision, the constraint forces will be violated
    % immediately, rendering event detection useless since it requires a
    % smoothly changing variable.  Therefore, we need to check the
    % constraint forces and turn them off if they act in the wrong
    % direction
%      if x_IC(3) > 0 && x_IC(3) < params.model.dyn.collision_threshold
%          disp('Put frontwheel constraint on again')
%          params.sim.constraints = ['flat_ground'];
%      end
    %disp('Collision');
%     [~,F] = robot_dynamics(0,x_IC');
%     for i1=1:4
%         if F(i1+2)<0, params.sim.constraints.uni(i1) = 0; end  % turn off unilateral constraints with negative forces
%     end
end

end


end
