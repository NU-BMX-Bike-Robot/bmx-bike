%% plot_robot.m
%
% Description:
%   Plots the robot in its current configuration.
%   
% Inputs:
%   q: robot configuration, q = [x_cart; theta_pend];
%   params: a struct with many elements, generated by calling init_params.m
%   varargin: optional name-value pair arguments:
%       'new_fig': (default: false), if true, plot appears on new figure
%
% Outputs:
%   none
%
% Notes:
%   1) This code is written verbosely in the hope that it is clear how to
%   extend it to visualizing other more complex robots.

function plot_robot(q,params,varargin)
%% Parse input arguments
% Note: a simple robot plotting function doesn't need this, but I want to
% write extensible code, so I'm using "varargin" which requires input
% parsing. See the reference below:
%
% https://people.umass.edu/whopper/posts/better-matlab-functions-with-the-inputparser-class/

% Step 1: instantiate an inputParser:
p = inputParser;

% Step 2: create the parsing schema:
%      2a: required inputs:
addRequired(p,'bike_config', ...
    @(q) isnumeric(q) && size(q,1)==5 && size(q,2)==1);
addRequired(p,'bike_params', ...
    @(params) ~isempty(params));
%      2b: optional inputs:
addParameter(p, 'new_fig', false); % if true, plot will be on a new figure

% Step 3: parse the inputs:
parse(p, q, params, varargin{:});

% Verification: display the results of parsing:
% disp(p.Results)


%% Compute the corners of the bike's body, clockwise from top left corner
% First compute the cart's home position (q(1) = 0):
body.home.upp_left.x    = -0.5*params.model.geom.body.w;
body.home.upp_left.y    = 0.5*params.model.geom.body.h;

body.home.upp_right.x   = 0.6*params.model.geom.body.w;
body.home.upp_right.y   = 0.2*params.model.geom.body.h;

body.home.upp_mid.x   = 0;
body.home.upp_mid.y   = 0.2*params.model.geom.body.h;

body.home.low_right.x   = 1*params.model.geom.body.w;
body.home.low_right.y   = -0.3*params.model.geom.body.h;

body.home.low_left.x    = -0.5*params.model.geom.body.w;
body.home.low_left.y    = -0.3*params.model.geom.body.h;

body.home.corners = horzcat([body.home.upp_left.x; body.home.upp_left.y; 1],...
                            [body.home.upp_mid.x; body.home.upp_mid.y; 1],...
                            [body.home.upp_right.x; body.home.upp_right.y; 1],...
                            [body.home.low_right.x; body.home.low_right.y; 1],...
                            [body.home.low_left.x;  body.home.low_left.y; 1]);

% Compute the 4 corners of the body after undergoing planar
% translation + rotation as described by T_body:

T_body = [cos(q(3)), -sin(q(3)), q(1);
          sin(q(3)),  cos(q(3)), q(2);
          0,          0,         1];
T_body_trans = [cos(0), -sin(0), q(1);
          sin(0),  cos(0), q(2);
          0,          0,         1];
body.curr.corners = T_body*body.home.corners;


%% Compute the location of the wheels
% The pendulum is a rectangle whose center is q(1) = x_cart. The pendulum
% can translate horizontally and can rotate, so we first compute a 
% homogeneous transformation matrix T_pend in SE(2):

%prev
% T_com_bw = [cos(0), -sin(0), -params.model.geom.bw_com.l*cos(params.model.geom.bw_com.theta);
%                sin(0),  cos(0), -params.model.geom.bw_com.l*sin(params.model.geom.bw_com.theta);
%                 0,          0,         1];
%             
% T_com_fw = [cos(0), -sin(0), -params.model.geom.fw_com.l*cos(params.model.geom.fw_com.theta);
%                sin(0),  cos(0), -params.model.geom.fw_com.l*sin(params.model.geom.fw_com.theta);
%                 0,          0,         1];
%prev

%edit
x_bw = params.model.geom.bw_com.l*cos(params.model.geom.bw_com.theta + q(3));
y_bw = params.model.geom.bw_com.l*sin(params.model.geom.bw_com.theta + q(3));

x_fw = params.model.geom.fw_com.l*cos(params.model.geom.fw_com.theta + q(3));
y_fw = params.model.geom.fw_com.l*sin(params.model.geom.fw_com.theta + q(3));

T_rot_com = [cos(-q(3)), -sin(-q(3)), 0;
            sin(-q(3)), cos(-q(3)), 0;
            0, 0, 1];
T_rot_com_legs = [cos(q(3)), -sin(q(3)), 0;
            sin(q(3)), cos(q(3)), 0;
            0, 0, 1];

T_rot_bw = [cos(q(4)), -sin(q(4)), 0;
            sin(q(4)), cos(q(4)), 0;
            0, 0, 1];

T_tran_bw = [1, 0, -x_bw;
            0, 1, -y_bw;
            0, 0, 1];

T_rot_fw = [cos(q(5)), -sin(q(5)), 0;
            sin(q(5)), cos(q(5)), 0;
            0, 0, 1];

T_tran_fw = [1, 0, -x_fw;
            0, 1, -y_fw;
            0, 0, 1];

T_tran_wheel_leg = [1, 0, 0;
                    0, 1, params.model.geom.leg.wheel_d;
                     0, 0, 1];
       

T_com_fw = T_rot_com*T_tran_bw*T_rot_bw;
T_com_bw = T_rot_com*T_tran_fw*T_rot_fw;
               

wheel.center = [0;0;1];
wheel.radius = [params.model.geom.wheel.r; 0; 1];                           


% Now compute the 4 corners of the legs after undergoing planar
% translation + rotation
wheel_fw.curr.center = T_body*T_com_fw*wheel.center;
wheel_bw.curr.center = T_body*T_com_bw*wheel.center;
wheel_fw.curr.radius = T_body*T_com_fw*wheel.radius;  
wheel_bw.curr.radius = T_body*T_com_bw*wheel.radius;
%% Compute the bike legs

%compute corners of leg at home
leg.home.low_right.x   =  0.5*params.model.geom.leg.w;
leg.home.low_right.y   =  -0.5*params.model.geom.leg.l;

leg.home.low_left.x   =  -0.5*params.model.geom.leg.w;
leg.home.low_left.y   =  -0.5*params.model.geom.leg.l;

leg.home.upp_right.x   =  0.5*params.model.geom.leg.w;
leg.home.upp_right.y   =  0.5*params.model.geom.leg.l;

leg.home.upp_left.x   =  -0.5*params.model.geom.leg.w;
leg.home.upp_left.y   =  0.5*params.model.geom.leg.l;


leg.home.corners = horzcat([leg.home.upp_left.x; leg.home.upp_left.y;   1],...
                            [leg.home.upp_right.x; leg.home.upp_right.y; 1],...
                            [leg.home.low_right.x; leg.home.low_right.y; 1],...
                            [leg.home.low_left.x;  leg.home.low_left.y;  1]);
                                              
leg_bw.corners = T_body_trans*T_tran_bw*T_rot_com_legs*T_tran_wheel_leg*leg.home.corners;                       
                        
leg_fw.corners = T_body_trans*T_tran_fw*T_rot_com_legs*T_tran_wheel_leg*leg.home.corners;
            
%% Display the cart, pendulum, and the pendulum's CoM
if p.Results.new_fig
    figure;
end

fill(body.curr.corners(1,:),body.curr.corners(2,:),params.viz.colors.body);
hold on;
fill(leg_bw.corners(1,:),leg_bw.corners(2,:),params.viz.colors.leg);
fill(leg_fw.corners(1,:),leg_fw.corners(2,:),params.viz.colors.leg);

%Create wheels
circle(wheel_bw.curr.center(1),wheel_bw.curr.center(2),params.model.geom.wheel.r,params.viz.colors.tracers.wheels);
circle(wheel_fw.curr.center(1),wheel_fw.curr.center(2),params.model.geom.wheel.r,params.viz.colors.tracers.wheels);
segment(wheel_bw.curr.center(1), wheel_bw.curr.center(2),wheel_bw.curr.radius(1),wheel_bw.curr.radius(2), 'red');
segment(wheel_fw.curr.center(1), wheel_fw.curr.center(2),wheel_fw.curr.radius(1),wheel_fw.curr.radius(2), 'red');

%Create back curve
%circle(body.curr.corners(1,1),q(2)+0.03, 0.35*params.model.geom.body.h,params.viz.colors.body);

%Add Marker for CoM
 plot(q(1), q(2),'o','MarkerSize',10,...
     'MarkerFaceColor',params.viz.colors.wheels,...
     'MarkerEdgeColor',params.viz.colors.wheels);
 
%Add ground line
yline(0);

hold off;

axis(params.viz.axis_lims);
daspect([1 1 1]) % no distortion

xlabel('$x$');
ylabel('$y$');

end


function circles = circle(x,y,r,c)
th = 0:pi/50:2*pi;
x_circle = r * cos(th) + x;
y_circle = r * sin(th) + y;
circles = plot(x_circle, y_circle);
fill(x_circle, y_circle, c)
end

function segments = segment(x1,y1,x2,y2,c)
x = [x1 x2];
y = [y1 y2];
segments = line(x,y,'Color',c);
end